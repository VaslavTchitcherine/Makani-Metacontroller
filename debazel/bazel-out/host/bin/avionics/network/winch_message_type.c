// Generated by generate_message_type.py; do not edit.

#include "avionics/network/winch_message_type.h"

#include <assert.h>
#include <string.h>

const char *WinchMessageTypeToString(WinchMessageType message_type) {
  switch (message_type) {
    // Fall-through intentional.
    default:
    case kNumWinchMessageTypes:
      assert(0);
      return "<unknown>";
    case kWinchMessageTypePlcWinchCommand:
      return "kWinchMessageTypePlcWinchCommand";
    case kWinchMessageTypePlcWinchSetState:
      return "kWinchMessageTypePlcWinchSetState";
    case kWinchMessageTypePlcWinchStatus:
      return "kWinchMessageTypePlcWinchStatus";
  }
}

const char *WinchMessageTypeToShortString(WinchMessageType message_type) {
  if (IsValidWinchMessageType(message_type)) {
    return WinchMessageTypeToString(message_type) + strlen("kWinchMessageType");
  } else {
    return "<error>";
  }
}

bool IsValidWinchMessageType(WinchMessageType message_type) {
  switch (message_type) {
    // Fall-through intentional.
    default:
    case kNumWinchMessageTypes:
      return false;
    case kWinchMessageTypePlcWinchCommand:
    case kWinchMessageTypePlcWinchSetState:
    case kWinchMessageTypePlcWinchStatus:
      return true;
  }
}

WinchMessageType StringToWinchMessageType(const char *message_type) {
  for (unsigned int i = 0; i < kNumWinchMessageTypes; ++i) {
    if (IsValidWinchMessageType(i)) {
      const char *name = WinchMessageTypeToString(i);
      if (!strcmp(name, message_type))
        return i;
      name = WinchMessageTypeToShortString(i);
      if (!strcmp(name, message_type))
        return i;
    }
  }
  return kNumWinchMessageTypes;
}
