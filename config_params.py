# This file is automatically generated.  Do not edit.

import ctypes
import yaml

import pack2
import py_types

class MotorType(ctypes._SimpleCData, py_types.PackableCType):
  _type_ = 'l'
  _value_map = {
    0: 'Protean',
    1: 'Yasa',
  }
  _c_value_map = {
    0: 'kMotorTypeProtean',
    1: 'kMotorTypeYasa',

  }
  _name_map = {
    'Protean': 0,
    'Yasa': 1,
  }
  max_value = 1
  min_value = 0

  def __init__(self, value=0):
    super(self.__class__, self).__init__()
    self.__setstate__(value)

  def __setstate__(self, state):
    if isinstance(state, basestring):
      self.value = self._name_map[state]
    elif isinstance(state, self.__class__):
      self.value = state.value
    else:
      self.value = state

  def __repr__(self):
    return self._value_map[self.value]

  def __hash__(self):
    return self.value

  def __eq__(self, other):
    if isinstance(other, basestring):
      return self.value == self._name_map[other]
    elif isinstance(other, self.__class__):
      return self.value == other.value
    else:
      return self.value == other

  def __ne__(self, other):
    return not self.__eq__(other)

  def CName(self):
    return self._c_value_map[self.value]

  @classmethod
  def Names(cls):
    return [MotorType(v) for v in cls._value_map.keys()]

  @classmethod
  def iteritems(cls):
    return cls._name_map.iteritems()

  @classmethod
  def HeaderFile(cls):
    return "avionics/motor/firmware/config_params.h"

  @classmethod
  def TypeName(cls):
    return "MotorType"

MotorType.PROTEAN = MotorType(0)
MotorType.YASA = MotorType(1)

class MotorPhaseSwap(ctypes._SimpleCData, py_types.PackableCType):
  _type_ = 'l'
  _value_map = {
    0: 'None',
    1: 'Ac',
  }
  _c_value_map = {
    0: 'kMotorPhaseSwapNone',
    1: 'kMotorPhaseSwapAc',

  }
  _name_map = {
    'None': 0,
    'Ac': 1,
  }
  max_value = 1
  min_value = 0

  def __init__(self, value=0):
    super(self.__class__, self).__init__()
    self.__setstate__(value)

  def __setstate__(self, state):
    if isinstance(state, basestring):
      self.value = self._name_map[state]
    elif isinstance(state, self.__class__):
      self.value = state.value
    else:
      self.value = state

  def __repr__(self):
    return self._value_map[self.value]

  def __hash__(self):
    return self.value

  def __eq__(self, other):
    if isinstance(other, basestring):
      return self.value == self._name_map[other]
    elif isinstance(other, self.__class__):
      return self.value == other.value
    else:
      return self.value == other

  def __ne__(self, other):
    return not self.__eq__(other)

  def CName(self):
    return self._c_value_map[self.value]

  @classmethod
  def Names(cls):
    return [MotorPhaseSwap(v) for v in cls._value_map.keys()]

  @classmethod
  def iteritems(cls):
    return cls._name_map.iteritems()

  @classmethod
  def HeaderFile(cls):
    return "avionics/motor/firmware/config_params.h"

  @classmethod
  def TypeName(cls):
    return "MotorPhaseSwap"

MotorPhaseSwap.NONE = MotorPhaseSwap(0)
MotorPhaseSwap.AC = MotorPhaseSwap(1)

class MotorCalibrator(ctypes._SimpleCData, py_types.PackableCType):
  _type_ = 'l'
  _value_map = {
    0: 'Disabled',
    1515870810: 'Enabled',
  }
  _c_value_map = {
    0: 'kMotorCalibratorDisabled',
    1515870810: 'kMotorCalibratorEnabled',

  }
  _name_map = {
    'Disabled': 0,
    'Enabled': 1515870810,
  }
  max_value = 1515870810
  min_value = 0

  def __init__(self, value=0):
    super(self.__class__, self).__init__()
    self.__setstate__(value)

  def __setstate__(self, state):
    if isinstance(state, basestring):
      self.value = self._name_map[state]
    elif isinstance(state, self.__class__):
      self.value = state.value
    else:
      self.value = state

  def __repr__(self):
    return self._value_map[self.value]

  def __hash__(self):
    return self.value

  def __eq__(self, other):
    if isinstance(other, basestring):
      return self.value == self._name_map[other]
    elif isinstance(other, self.__class__):
      return self.value == other.value
    else:
      return self.value == other

  def __ne__(self, other):
    return not self.__eq__(other)

  def CName(self):
    return self._c_value_map[self.value]

  @classmethod
  def Names(cls):
    return [MotorCalibrator(v) for v in cls._value_map.keys()]

  @classmethod
  def iteritems(cls):
    return cls._name_map.iteritems()

  @classmethod
  def HeaderFile(cls):
    return "avionics/motor/firmware/config_params.h"

  @classmethod
  def TypeName(cls):
    return "MotorCalibrator"

MotorCalibrator.DISABLED = MotorCalibrator(0)
MotorCalibrator.ENABLED = MotorCalibrator(1515870810)

class MotorLoadType(ctypes._SimpleCData, py_types.PackableCType):
  _type_ = 'l'
  _value_map = {
    0: 'None',
    1: 'PropRev1NegativeX',
    2: 'PropRev2PositiveX',
    3: 'Dyno',
  }
  _c_value_map = {
    0: 'kMotorLoadTypeNone',
    1: 'kMotorLoadTypePropRev1NegativeX',
    2: 'kMotorLoadTypePropRev2PositiveX',
    3: 'kMotorLoadTypeDyno',

  }
  _name_map = {
    'None': 0,
    'PropRev1NegativeX': 1,
    'PropRev2PositiveX': 2,
    'Dyno': 3,
  }
  max_value = 3
  min_value = 0

  def __init__(self, value=0):
    super(self.__class__, self).__init__()
    self.__setstate__(value)

  def __setstate__(self, state):
    if isinstance(state, basestring):
      self.value = self._name_map[state]
    elif isinstance(state, self.__class__):
      self.value = state.value
    else:
      self.value = state

  def __repr__(self):
    return self._value_map[self.value]

  def __hash__(self):
    return self.value

  def __eq__(self, other):
    if isinstance(other, basestring):
      return self.value == self._name_map[other]
    elif isinstance(other, self.__class__):
      return self.value == other.value
    else:
      return self.value == other

  def __ne__(self, other):
    return not self.__eq__(other)

  def CName(self):
    return self._c_value_map[self.value]

  @classmethod
  def Names(cls):
    return [MotorLoadType(v) for v in cls._value_map.keys()]

  @classmethod
  def iteritems(cls):
    return cls._name_map.iteritems()

  @classmethod
  def HeaderFile(cls):
    return "avionics/motor/firmware/config_params.h"

  @classmethod
  def TypeName(cls):
    return "MotorLoadType"

MotorLoadType.NONE = MotorLoadType(0)
MotorLoadType.PROP_REV1_NEGATIVE_X = MotorLoadType(1)
MotorLoadType.PROP_REV2_POSITIVE_X = MotorLoadType(2)
MotorLoadType.DYNO = MotorLoadType(3)

class MotorBusTopology(ctypes._SimpleCData, py_types.PackableCType):
  _type_ = 'l'
  _value_map = {
    0: 'Single',
    1: 'Stacked',
  }
  _c_value_map = {
    0: 'kMotorBusTopologySingle',
    1: 'kMotorBusTopologyStacked',

  }
  _name_map = {
    'Single': 0,
    'Stacked': 1,
  }
  max_value = 1
  min_value = 0

  def __init__(self, value=0):
    super(self.__class__, self).__init__()
    self.__setstate__(value)

  def __setstate__(self, state):
    if isinstance(state, basestring):
      self.value = self._name_map[state]
    elif isinstance(state, self.__class__):
      self.value = state.value
    else:
      self.value = state

  def __repr__(self):
    return self._value_map[self.value]

  def __hash__(self):
    return self.value

  def __eq__(self, other):
    if isinstance(other, basestring):
      return self.value == self._name_map[other]
    elif isinstance(other, self.__class__):
      return self.value == other.value
    else:
      return self.value == other

  def __ne__(self, other):
    return not self.__eq__(other)

  def CName(self):
    return self._c_value_map[self.value]

  @classmethod
  def Names(cls):
    return [MotorBusTopology(v) for v in cls._value_map.keys()]

  @classmethod
  def iteritems(cls):
    return cls._name_map.iteritems()

  @classmethod
  def HeaderFile(cls):
    return "avionics/motor/firmware/config_params.h"

  @classmethod
  def TypeName(cls):
    return "MotorBusTopology"

MotorBusTopology.SINGLE = MotorBusTopology(0)
MotorBusTopology.STACKED = MotorBusTopology(1)

class MotorConfigParams (py_types.Structure):
  global MotorType
  global MotorPhaseSwap
  global MotorBusTopology
  global MotorLoadType
  global MotorCalibrator

  _fields_ = [
      ('motor_type', MotorType),
      ('phase_swap', MotorPhaseSwap),
      ('load_type', MotorLoadType),
      ('calibrator_enable', MotorCalibrator),
      ('topology', MotorBusTopology),

  ]
  _offsets_ = {
      'motor_type': 0,
      'phase_swap': 4,
      'load_type': 8,
      'calibrator_enable': 12,
      'topology': 16,

  }
  size = 20
  alignment = 4
  crc = 0x5c7bd5de
  source = "enum32 MotorType{Protean=0,Yasa=1,}enum32 MotorPhaseSwap{None=0,Ac=1,}enum32 MotorLoadType{None=0,PropRev1NegativeX=1,PropRev2PositiveX=2,Dyno=3,}enum32 MotorCalibrator{Disabled=0,Enabled=1515870810,}enum32 MotorBusTopology{Single=0,Stacked=1,}param MotorConfigParams{MotorType motor_type;MotorPhaseSwap phase_swap;MotorLoadType load_type;MotorCalibrator calibrator_enable;MotorBusTopology topology;}"
pack2.RegisterParam(MotorConfigParams)



class MotorConfigParamsYamlLoader(yaml.YAMLObject):
  global MotorConfigParams
  global yaml
  yaml_tag = '!MotorConfigParams'
  yaml_loader = yaml.SafeLoader
  data_type = MotorConfigParams

  @classmethod
  def from_yaml(cls, loader, node):
    # Clear object cache to ensure all objects are deep.
    loader.constructed_objects = {}
    state = loader.construct_mapping(node, deep=True)
    return MotorConfigParams(state=state)


